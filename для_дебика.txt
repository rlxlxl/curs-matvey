═══════════════════════════════════════════════════════════════════════════════
  ПОДРОБНОЕ ОБЪЯСНЕНИЕ КАК РАБОТАЕТ ПРОГРАММА
  Система управления логистическими перевозками
═══════════════════════════════════════════════════════════════════════════════

ЧТО ЭТО ЗА ПРОГРАММА?
───────────────────────────────────────────────────────────────────────────────

Это веб-приложение для управления перевозками грузов. Представь, что у тебя 
есть транспортная компания, и тебе нужно вести учет всех перевозок: что везешь,
откуда, куда, какой груз, какой водитель, какая машина и т.д.

Программа позволяет:
- Добавлять новые перевозки
- Просматривать все перевозки в удобной таблице
- Редактировать существующие перевозки
- Удалять перевозки
- Видеть статус каждой перевозки (ожидает, в пути, доставлено)


ЧАСТЬ 1: ИЗ ЧЕГО СОСТОИТ ПРОГРАММА
───────────────────────────────────────────────────────────────────────────────

Программа состоит из трех основных частей:

1. БАЗА ДАННЫХ (PostgreSQL)
   ────────────────────────────────────────────────────────────────────────────
   Это как большая электронная таблица, где хранится вся информация.
   В базе данных есть несколько таблиц:
   
   - Таблица "clients" (клиенты) - хранит информацию о заказчиках
   - Таблица "vehicles" (транспорт) - хранит информацию о машинах
   - Таблица "drivers" (водители) - хранит информацию о водителях
   - Таблица "shipments" (перевозки) - хранит информацию о перевозках
   
   Все эти таблицы связаны между собой. Например, в таблице перевозок есть
   ссылки на клиента, машину и водителя.

2. БЭКЕНД (C++ сервер)
   ────────────────────────────────────────────────────────────────────────────
   Это программа на C++, которая:
   - Слушает запросы от браузера (на порту 8080)
   - Получает данные из базы данных
   - Обрабатывает запросы (добавить, изменить, удалить перевозку)
   - Отправляет ответы обратно в браузер
   
   Это как официант в ресторане: браузер (клиент) делает заказ, бэкенд
   идет на кухню (в базу данных), берет нужное и приносит обратно.

3. ФРОНТЕНД (HTML страница)
   ────────────────────────────────────────────────────────────────────────────
   Это красивая веб-страница, которую видит пользователь в браузере.
   На ней есть:
   - Форма для добавления новой перевозки
   - Таблица со всеми перевозками
   - Кнопки для редактирования и удаления
   
   Когда пользователь что-то делает (например, нажимает кнопку "Добавить"),
   страница отправляет запрос бэкенду, получает ответ и обновляет таблицу.


ЧАСТЬ 2: КАК ЭТО ВСЕ ЗАПУСКАЕТСЯ (DOCKER)
───────────────────────────────────────────────────────────────────────────────

Вместо того чтобы устанавливать все вручную, программа использует Docker.
Docker - это как виртуальные контейнеры, в каждом из которых работает своя
часть программы.

В файле docker-compose.yml описаны два контейнера:

1. Контейнер "postgres" (база данных)
   - Запускает PostgreSQL базу данных
   - Создает базу данных "logistics_db"
   - Выполняет скрипт init.sql, который создает все таблицы и заполняет их
     тестовыми данными
   - Слушает на порту 5432

2. Контейнер "backend" (сервер)
   - Компилирует C++ код в исполняемый файл
   - Запускает HTTP сервер на порту 8080
   - Подключается к базе данных
   - Отдает HTML страницу и обрабатывает API запросы

Когда ты запускаешь "docker-compose up", происходит следующее:
1. Docker создает сеть для связи контейнеров
2. Запускается контейнер с базой данных
3. База данных инициализируется (создаются таблицы, добавляются тестовые данные)
4. Запускается контейнер с бэкендом
5. Бэкенд подключается к базе данных
6. Все готово! Можно открывать браузер и идти на http://localhost:8080


ЧАСТЬ 3: КАК РАБОТАЕТ БАЗА ДАННЫХ
───────────────────────────────────────────────────────────────────────────────

Файл database/init.sql содержит SQL команды, которые выполняются при первом
запуске базы данных.

Что происходит:

1. СОЗДАНИЕ ТАБЛИЦ
   ────────────────────────────────────────────────────────────────────────────
   CREATE TABLE clients - создает таблицу клиентов
   CREATE TABLE vehicles - создает таблицу транспорта
   CREATE TABLE drivers - создает таблицу водителей
   CREATE TABLE shipments - создает таблицу перевозок
   
   В таблице shipments есть поля:
   - id - уникальный номер перевозки
   - client_id - ссылка на клиента (какой клиент заказал)
   - vehicle_id - ссылка на машину (какая машина используется)
   - driver_id - ссылка на водителя (кто ведет)
   - cargo_description - описание груза
   - origin - откуда везти
   - destination - куда везти
   - weight_kg - вес в килограммах
   - volume_m3 - объем в кубометрах
   - status - статус (pending, в_пути, доставлено, ожидает)
   - created_at - когда создана запись
   - updated_at - когда последний раз обновлена

2. ДОБАВЛЕНИЕ ТЕСТОВЫХ ДАННЫХ
   ────────────────────────────────────────────────────────────────────────────
   INSERT INTO clients - добавляет 4 тестовых клиента
   INSERT INTO vehicles - добавляет 5 тестовых машин
   INSERT INTO drivers - добавляет 5 тестовых водителей
   INSERT INTO shipments - добавляет 5 тестовых перевозок

3. СОЗДАНИЕ СВЯЗЕЙ (JOIN)
   ────────────────────────────────────────────────────────────────────────────
   Когда бэкенд запрашивает перевозки, он использует JOIN, чтобы получить
   не только данные из таблицы shipments, но и связанные данные:
   - Имя клиента из таблицы clients
   - Тип транспорта и номер машины из таблицы vehicles
   - Имя водителя из таблицы drivers
   
   Это как если бы ты смотрел на перевозку и сразу видел все связанные данные,
   а не только ID номерки.


ЧАСТЬ 4: КАК РАБОТАЕТ БЭКЕНД (C++ СЕРВЕР)
───────────────────────────────────────────────────────────────────────────────

Файл backend/main.cpp содержит весь код сервера. Разберем по частям:

1. КЛАСС HTTPServer
   ────────────────────────────────────────────────────────────────────────────
   Это главный класс, который делает всю работу. У него есть:
   
   - server_fd - файловый дескриптор сокета (как "дверь" для подключений)
   - conn - соединение с базой данных PostgreSQL
   - port - номер порта (8080)

2. КОНСТРУКТОР (HTTPServer::HTTPServer)
   ────────────────────────────────────────────────────────────────────────────
   Когда создается сервер, он:
   
   а) Создает сокет (socket) - это как открывает "дверь" для подключений
      socket(AF_INET, SOCK_STREAM, 0)
   
   б) Настраивает сокет на прослушивание порта 8080
      bind(server_fd, ...) - привязывает сокет к порту
      listen(server_fd, 10) - начинает слушать подключения
   
   в) Подключается к базе данных PostgreSQL
      PQconnectdb("host=postgres port=5432 dbname=logistics_db ...")
      Это строка подключения говорит: "Подключись к базе данных postgres
      (это имя контейнера), на порту 5432, база данных logistics_db,
      пользователь logistics_user, пароль logistics_pass"

3. МЕТОД run()
   ────────────────────────────────────────────────────────────────────────────
   Это бесконечный цикл, который:
   
   а) Ждет подключения от браузера
      accept(server_fd, ...) - принимает новое подключение
   
   б) Для каждого подключения создает отдельный поток (thread)
      std::thread(&HTTPServer::handleRequest, this, client_fd).detach()
      Это значит, что если к серверу подключились 5 человек одновременно,
      каждый будет обработан в своем потоке, не мешая друг другу.

4. МЕТОД handleRequest()
   ────────────────────────────────────────────────────────────────────────────
   Это самая важная функция! Она обрабатывает каждый запрос от браузера.
   
   Что она делает:
   
   а) ЧИТАЕТ ЗАПРОС
      read(client_fd, buffer, 4096) - читает данные из сокета
      Запрос выглядит примерно так:
      "GET /api/shipments HTTP/1.1\r\nHost: localhost:8080\r\n\r\n"
      или
      "POST /api/shipments HTTP/1.1\r\nContent-Type: ...\r\n\r\ncargo_description=..."
   
   б) ПАРСИТ ЗАПРОС (разбирает на части)
      - Извлекает метод (GET, POST, PUT, DELETE)
      - Извлекает путь (/api/shipments, /api/shipments/5, и т.д.)
      - Извлекает тело запроса (если есть)
      - Парсит параметры из тела запроса
   
   в) ВЫПОЛНЯЕТ ДЕЙСТВИЕ в зависимости от метода и пути:
      
      GET /api/shipments
      → Вызывает getAllShipments()
      → Выполняет SQL запрос с JOIN для получения всех перевозок
      → Формирует JSON ответ
      → Отправляет ответ браузеру
      
      POST /api/shipments
      → Вызывает createShipment()
      → Проверяет обязательные поля
      → Выполняет INSERT запрос с использованием prepared statement
      → Возвращает ID созданной перевозки
      
      PUT /api/shipments/{id}
      → Вызывает updateShipment()
      → Выполняет UPDATE запрос с prepared statement
      → Обновляет перевозку с указанным ID
      
      DELETE /api/shipments/{id}
      → Вызывает deleteShipment()
      → Выполняет DELETE запрос с prepared statement
      → Удаляет перевозку с указанным ID
      
      GET / или GET /index.html
      → Читает файл frontend/index.html
      → Отправляет его как HTML страницу
   
   г) ОТПРАВЛЯЕТ ОТВЕТ
      sendResponse() формирует HTTP ответ:
      "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n{...json...}"
      И отправляет его обратно в браузер

5. ЗАЩИТА ОТ SQL-ИНЪЕКЦИЙ
   ────────────────────────────────────────────────────────────────────────────
   Очень важно! Программа использует prepared statements (подготовленные
   запросы) для защиты от SQL-инъекций.
   
   ПЛОХО (опасно):
   "INSERT INTO shipments VALUES ('" + user_input + "')"
   Если пользователь введет что-то вроде "'); DROP TABLE shipments; --",
   то база данных может быть повреждена!
   
   ХОРОШО (безопасно):
   "INSERT INTO shipments VALUES ($1, $2, $3)"
   И затем передаем параметры отдельно:
   PQexecParams(conn, query, 3, nullptr, paramValues, ...)
   
   PostgreSQL сам правильно обработает параметры, экранирует специальные
   символы, и никакая SQL-инъекция не пройдет.

6. ФОРМИРОВАНИЕ JSON
   ────────────────────────────────────────────────────────────────────────────
   Когда нужно отправить данные в браузер, сервер формирует JSON строку:
   
   {
     "shipments": [
       {
         "id": 1,
         "cargo_description": "Электроника",
         "origin": "Москва",
         "destination": "Санкт-Петербург",
         ...
       },
       ...
     ]
   }
   
   Для этого используется функция escapeJson(), которая экранирует
   специальные символы (кавычки, переносы строк и т.д.), чтобы JSON
   был валидным.


ЧАСТЬ 5: КАК РАБОТАЕТ ФРОНТЕНД (HTML СТРАНИЦА)
───────────────────────────────────────────────────────────────────────────────

Файл frontend/index.html содержит HTML, CSS и JavaScript код.

1. HTML СТРУКТУРА
   ────────────────────────────────────────────────────────────────────────────
   - <header> - заголовок страницы
   - <div class="admin-panel"> - форма для добавления перевозки
   - <div class="shipments-container"> - контейнер для таблицы перевозок
   - <div id="editModal"> - модальное окно для редактирования

2. CSS СТИЛИ
   ────────────────────────────────────────────────────────────────────────────
   Внутри <style> тега описаны все стили:
   - Красивый градиентный фон
   - Стили для кнопок, таблиц, форм
   - Анимации при наведении
   - Адаптивный дизайн

3. JAVASCRIPT ЛОГИКА
   ────────────────────────────────────────────────────────────────────────────
   Внутри <script> тега находится весь JavaScript код:
   
   а) ФУНКЦИЯ loadShipments()
      - Отправляет GET запрос на http://localhost:8080/api/shipments
      - Получает JSON с перевозками
      - Создает HTML таблицу и заполняет ее данными
      - Вставляет таблицу в страницу
   
   б) ОБРАБОТЧИК ФОРМЫ ДОБАВЛЕНИЯ
      document.getElementById('shipment-form').addEventListener('submit', ...)
      - Когда пользователь нажимает "Добавить перевозку"
      - Собирает данные из полей формы
      - Формирует строку параметров (cargo_description=...&origin=...)
      - Отправляет POST запрос на /api/shipments
      - Если успешно - показывает сообщение и обновляет таблицу
      - Если ошибка - показывает сообщение об ошибке
   
   в) ФУНКЦИЯ editShipment(id)
      - Загружает все перевозки
      - Находит нужную по ID
      - Заполняет форму редактирования данными
      - Показывает модальное окно
   
   г) ОБРАБОТЧИК ФОРМЫ РЕДАКТИРОВАНИЯ
      - Собирает данные из формы
      - Отправляет PUT запрос на /api/shipments/{id}
      - Обновляет таблицу
   
   д) ФУНКЦИЯ deleteShipment(id)
      - Показывает подтверждение
      - Отправляет DELETE запрос на /api/shipments/{id}
      - Обновляет таблицу


ЧАСТЬ 6: ПОЛНЫЙ ЦИКЛ РАБОТЫ (ПРИМЕР)
───────────────────────────────────────────────────────────────────────────────

Давай проследим, что происходит, когда пользователь добавляет новую перевозку:

ШАГ 1: ПОЛЬЗОВАТЕЛЬ ЗАПОЛНЯЕТ ФОРМУ
───────────────────────────────────────────────────────────────────────────────
Пользователь открывает http://localhost:8080 в браузере.
Видит красивую страницу с формой.
Заполняет поля:
- Описание груза: "Мебель"
- Откуда: "Москва"
- Куда: "Казань"
- Вес: 500
- Тип транспорта: "Грузовик"
- Статус: "Ожидает"
Нажимает кнопку "Добавить перевозку"

ШАГ 2: JAVASCRIPT ОБРАБАТЫВАЕТ НАЖАТИЕ
───────────────────────────────────────────────────────────────────────────────
JavaScript перехватывает событие submit формы.
Собирает данные из полей:
  cargo_description=Мебель
  origin=Москва
  destination=Казань
  weight_kg=500
  transport_type=Грузовик
  status=Ожидает

Формирует строку:
"cargo_description=Мебель&origin=Москва&destination=Казань&weight_kg=500&transport_type=Грузовик&status=Ожидает"

Отправляет HTTP POST запрос:
POST http://localhost:8080/api/shipments
Content-Type: application/x-www-form-urlencoded
Body: cargo_description=Мебель&origin=Москва&...

ШАГ 3: БЭКЕНД ПОЛУЧАЕТ ЗАПРОС
───────────────────────────────────────────────────────────────────────────────
Сервер C++ принимает подключение через accept().
Создает новый поток для обработки.
В потоке вызывается handleRequest().

handleRequest() читает запрос из сокета:
"POST /api/shipments HTTP/1.1\r\n
Content-Type: application/x-www-form-urlencoded\r\n
Content-Length: 123\r\n
\r\n
cargo_description=Мебель&origin=Москва&..."

Парсит запрос:
- Метод: POST
- Путь: /api/shipments
- Тело: cargo_description=Мебель&origin=Москва&...

ШАГ 4: БЭКЕНД ОБРАБАТЫВАЕТ ЗАПРОС
───────────────────────────────────────────────────────────────────────────────
handleRequest() видит, что это POST /api/shipments.
Вызывает parseQuery() для парсинга параметров.
Получает map:
  cargo_description -> "Мебель"
  origin -> "Москва"
  destination -> "Казань"
  weight_kg -> "500"
  transport_type -> "Грузовик"
  status -> "Ожидает"

Проверяет обязательные поля - все есть.
Вызывает createShipment().

ШАГ 5: СОЗДАНИЕ В БАЗЕ ДАННЫХ
───────────────────────────────────────────────────────────────────────────────
createShipment() формирует SQL запрос с prepared statement:
"INSERT INTO shipments (cargo_description, origin, destination, weight_kg, volume_m3, status) 
 VALUES ($1, $2, $3, $4, $5, $6) RETURNING id"

Подготавливает параметры:
  paramValues[0] = "Мебель"
  paramValues[1] = "Москва"
  paramValues[2] = "Казань"
  paramValues[3] = "500"
  paramValues[4] = nullptr (volume_m3 не указан)
  paramValues[5] = "Ожидает"

Выполняет запрос через PQexecParams().
PostgreSQL безопасно обрабатывает параметры и вставляет запись.
Возвращает ID новой записи, например 6.

ШАГ 6: БЭКЕНД ОТПРАВЛЯЕТ ОТВЕТ
───────────────────────────────────────────────────────────────────────────────
createShipment() возвращает JSON:
{"success":true,"id":6}

handleRequest() формирует HTTP ответ:
"HTTP/1.1 201 Created\r\n
Content-Type: application/json\r\n
Content-Length: 20\r\n
Access-Control-Allow-Origin: *\r\n
\r\n
{\"success\":true,\"id\":6}"

Отправляет ответ через send().
Закрывает соединение.

ШАГ 7: БРАУЗЕР ПОЛУЧАЕТ ОТВЕТ
───────────────────────────────────────────────────────────────────────────────
JavaScript получает ответ от сервера.
Парсит JSON: {success: true, id: 6}
Показывает сообщение: "Перевозка успешно добавлена"
Очищает форму
Вызывает loadShipments() для обновления таблицы

ШАГ 8: ОБНОВЛЕНИЕ ТАБЛИЦЫ
───────────────────────────────────────────────────────────────────────────────
loadShipments() отправляет GET запрос на /api/shipments
Бэкенд получает запрос, вызывает getAllShipments()
getAllShipments() выполняет SQL запрос с JOIN:
"SELECT s.id, s.cargo_description, ..., c.name, v.vehicle_type, d.full_name
 FROM shipments s
 LEFT JOIN clients c ON s.client_id = c.id
 LEFT JOIN vehicles v ON s.vehicle_id = v.id
 LEFT JOIN drivers d ON s.driver_id = d.id
 ORDER BY s.id"

Получает все перевозки, включая новую.
Формирует JSON со всеми перевозками.
Отправляет ответ.

JavaScript получает данные, создает HTML таблицу, вставляет в страницу.
Пользователь видит обновленную таблицу с новой перевозкой!


ЧАСТЬ 7: КАК ЗАПУСТИТЬ ПРОГРАММУ
───────────────────────────────────────────────────────────────────────────────

1. УСТАНОВКА DOCKER
   ────────────────────────────────────────────────────────────────────────────
   Если у тебя еще нет Docker:
   - Скачай Docker Desktop с официального сайта
   - Установи его
   - Запусти Docker Desktop

2. ЗАПУСК ПРОГРАММЫ
   ────────────────────────────────────────────────────────────────────────────
   Открой терминал в папке с проектом.
   
   Вариант 1 (через Makefile):
   make up-build
   
   Вариант 2 (через docker-compose):
   docker-compose up --build
   
   Что происходит:
   - Docker читает docker-compose.yml
   - Скачивает образ PostgreSQL (если нужно)
   - Собирает образ бэкенда (компилирует C++ код)
   - Запускает контейнер с базой данных
   - База данных выполняет init.sql (создает таблицы, добавляет данные)
   - Запускает контейнер с бэкендом
   - Бэкенд подключается к базе данных
   - Все готово!

3. ОТКРЫТИЕ В БРАУЗЕРЕ
   ────────────────────────────────────────────────────────────────────────────
   Открой браузер и перейди по адресу:
   http://localhost:8080
   
   Ты увидишь красивую страницу с формой и таблицей перевозок.

4. ОСТАНОВКА ПРОГРАММЫ
   ────────────────────────────────────────────────────────────────────────────
   Нажми Ctrl+C в терминале, или выполни:
   make down
   или
   docker-compose down


ЧАСТЬ 8: ВАЖНЫЕ ДЕТАЛИ
───────────────────────────────────────────────────────────────────────────────

1. ПОРТЫ
   ────────────────────────────────────────────────────────────────────────────
   - 8080 - порт для веб-сервера (браузер подключается сюда)
   - 5432 - порт для PostgreSQL (бэкенд подключается сюда)
   
   Если порт 8080 занят, можно изменить в docker-compose.yml:
   ports:
     - "8081:8080"  # Теперь будет доступно на http://localhost:8081

2. ДАННЫЕ В БАЗЕ
   ────────────────────────────────────────────────────────────────────────────
   При первом запуске база данных автоматически заполняется тестовыми данными:
   - 4 клиента
   - 5 машин
   - 5 водителей
   - 5 перевозок
   
   Если хочешь начать с чистой базы:
   make db-reset

3. ЛОГИ
   ────────────────────────────────────────────────────────────────────────────
   Чтобы посмотреть, что происходит в контейнерах:
   make logs          # Логи всех сервисов
   make logs-backend  # Только логи бэкенда
   make logs-postgres # Только логи базы данных

4. ПОДКЛЮЧЕНИЕ К БАЗЕ ДАННЫХ
   ────────────────────────────────────────────────────────────────────────────
   Если хочешь посмотреть базу данных напрямую:
   make db-connect
   
   Это откроет psql (консоль PostgreSQL), где можно выполнять SQL запросы:
   SELECT * FROM shipments;
   SELECT * FROM clients;
   и т.д.


ЧАСТЬ 9: ЧТО ПРОИСХОДИТ ПОД КАПОТОМ (ТЕХНИЧЕСКИЕ ДЕТАЛИ)
───────────────────────────────────────────────────────────────────────────────

1. HTTP ПРОТОКОЛ
   ────────────────────────────────────────────────────────────────────────────
   Браузер и сервер общаются по протоколу HTTP.
   
   Запрос выглядит так:
   POST /api/shipments HTTP/1.1
   Host: localhost:8080
   Content-Type: application/x-www-form-urlencoded
   Content-Length: 123
   
   cargo_description=Мебель&origin=Москва&...
   
   Ответ выглядит так:
   HTTP/1.1 201 Created
   Content-Type: application/json
   Content-Length: 20
   
   {"success":true,"id":6}

2. СОКЕТЫ
   ────────────────────────────────────────────────────────────────────────────
   Сокет - это способ общения программ через сеть.
   Сервер создает сокет, привязывает его к порту 8080, и начинает слушать.
   Когда браузер подключается, создается новый сокет для этого подключения.
   Через этот сокет идут данные туда-сюда.

3. ПОТОКИ (THREADS)
   ────────────────────────────────────────────────────────────────────────────
   Для каждого подключения создается отдельный поток.
   Это значит, что если к серверу подключились 10 человек одновременно,
   каждый будет обработан параллельно, не мешая друг другу.
   
   std::thread(&HTTPServer::handleRequest, this, client_fd).detach()
   - Создает новый поток
   - Вызывает handleRequest() в этом потоке
   - detach() означает, что поток работает независимо

4. JSON ФОРМАТ
   ────────────────────────────────────────────────────────────────────────────
   JSON (JavaScript Object Notation) - это формат для передачи данных.
   Выглядит как JavaScript объект:
   {
     "shipments": [
       {
         "id": 1,
         "cargo_description": "Электроника",
         "origin": "Москва"
       }
     ]
   }
   
   Легко читается и обрабатывается JavaScript в браузере.

5. SQL JOIN
   ────────────────────────────────────────────────────────────────────────────
   JOIN позволяет объединить данные из нескольких таблиц.
   
   Например, в таблице shipments хранится только ID клиента (client_id = 1).
   Но нам нужно имя клиента!
   
   Поэтому используется LEFT JOIN:
   SELECT s.*, c.name
   FROM shipments s
   LEFT JOIN clients c ON s.client_id = c.id
   
   Это говорит: "Возьми все из shipments, и добавь имя клиента из clients,
   где ID совпадают".

6. PREPARED STATEMENTS
   ────────────────────────────────────────────────────────────────────────────
   Prepared statement - это способ безопасно выполнять SQL запросы.
   
   Вместо:
   "INSERT INTO shipments VALUES ('" + user_input + "')"
   
   Используется:
   "INSERT INTO shipments VALUES ($1)"
   И параметр передается отдельно.
   
   PostgreSQL сам правильно обработает параметр, экранирует специальные
   символы, и никакая SQL-инъекция не пройдет.


ЧАСТЬ 10: ВОЗМОЖНЫЕ ПРОБЛЕМЫ И РЕШЕНИЯ
───────────────────────────────────────────────────────────────────────────────

1. ПОРТ 8080 УЖЕ ЗАНЯТ
   ────────────────────────────────────────────────────────────────────────────
   Ошибка: "Bind failed" или "Address already in use"
   
   Решение:
   - Найди, что занимает порт: lsof -i :8080
   - Останови это приложение
   - Или измени порт в docker-compose.yml

2. БАЗА ДАННЫХ НЕ ПОДКЛЮЧАЕТСЯ
   ────────────────────────────────────────────────────────────────────────────
   Ошибка: "Connection to database failed"
   
   Решение:
   - Убедись, что контейнер postgres запущен: docker-compose ps
   - Посмотри логи: make logs-postgres
   - Подожди немного, база данных может еще инициализироваться

3. СТРАНИЦА НЕ ОТКРЫВАЕТСЯ
   ────────────────────────────────────────────────────────────────────────────
   Ошибка: Страница не загружается или показывает ошибку
   
   Решение:
   - Убедись, что контейнеры запущены: docker-compose ps
   - Посмотри логи бэкенда: make logs-backend
   - Проверь, что открываешь правильный адрес: http://localhost:8080

4. ДАННЫЕ НЕ ОТОБРАЖАЮТСЯ
   ────────────────────────────────────────────────────────────────────────────
   Ошибка: Таблица пустая или показывает ошибку
   
   Решение:
   - Открой консоль браузера (F12) и посмотри ошибки
   - Проверь, что бэкенд отвечает: curl http://localhost:8080/api/shipments
   - Посмотри логи: make logs-backend

5. ИЗМЕНЕНИЯ НЕ СОХРАНЯЮТСЯ
   ────────────────────────────────────────────────────────────────────────────
   Ошибка: После перезапуска контейнеров данные пропадают
   
   Решение:
   - Данные хранятся в Docker volume "postgres_data"
   - Если используешь "docker-compose down -v", volume удаляется
   - Используй просто "docker-compose down" для сохранения данных


═══════════════════════════════════════════════════════════════════════════════
  КОНЕЦ ОБЪЯСНЕНИЯ
═══════════════════════════════════════════════════════════════════════════════

Надеюсь, теперь тебе понятно, как работает программа! Если что-то непонятно,
перечитай нужную часть еще раз. Программа довольно простая, но в ней много
интересных деталей.

Удачи в изучении! 🚀

